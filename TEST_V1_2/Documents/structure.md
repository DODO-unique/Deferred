# `structure.md`

**Project:** `TEST_v1_2`
**Codename:** `touch-engine-dock`

---

## Overview

`TEST_v1_2` is a **flow-driven backend spine** designed to receive intent from a minimal frontend, resolve that intent into structured operations, manage operation state, and persist deferred execution safely.

This version focuses on **control flow correctness**, **explicit state transitions**, and **clear layer boundaries**.
UI, orchestration polish, and advanced CRUD support are intentionally deferred to later versions.

This is not a product surface. This is the spinal cord.

---

## Core Goals (Tv_1.2)

1. **Establish a minimal but strict DB boundary**

   * One primary table for deferred operations.
   * DB is treated as a hostile boundary.
   * All data persisted must pass rigid validation.

2. **Stabilize Dock as the protocol boundary**

   * Dock receives external packets.
   * Validates request and response *shape* only.
   * Resolves enums into executable actions.
   * Does not own business logic or state transitions.

3. **Formalize Engine as the flow authority**

   * Engine owns operation state.
   * Defines valid state transitions (currently `create/init`).
   * Produces structured instructions for Dock.
   * Logs flow decisions centrally.

4. **Separate validation concerns**

   * Endpoint / protocol validation at Dock.
   * Flow-aware validation around Engine.
   * Boundary validation before DB persistence.
   * Validation is explicit, named, and non-ambient.

5. **Keep Touch intentionally naive**

   * Touch is a logging-heavy ORM / persistence layer.
   * No business logic.
   * No flow decisions.
   * Trusts data passed *after* boundary validation.

---

## System Flow (Conceptual)

```
Frontend
   ↓
Dock (protocol + enum resolution)
   ↓
Flow Validator (stage-aware, permissive)
   ↓
Engine (operation state + decisions)
   ↓
Boundary Validator (strict, DB-aligned)
   ↓
Touch (ORM / DB interface)
   ↓
Database
```

Each layer answers a **different question** and must not leak responsibility upward or downward.

---

## Layer Responsibilities

### Dock

**Role:** External interface and protocol gate.

Responsibilities:

* Accept requests from frontend.
* Perform immediate request validation (shape, required fields).
* Resolve enums into callable actions.
* Dispatch control to Engine.
* Validate outgoing response structure before returning.

Non-responsibilities:

* Business logic.
* State mutation.
* DB interaction.

Dock is intentionally thin and synchronous.

---

### resolver

**Role:** Intent resolution.

* resolver map high-level intent (e.g. `CREATE`) to executable handlers.
* Each enum resolves to a function, not a class.
* resolver do not own state.

resolver act as a controlled switchboard.

---

### Engine

**Role:** Flow brain.

Responsibilities:

* Maintain operation state.
* Enforce valid state transitions.
* Interpret input from Dock into meaningful state changes.
* Produce instructions for Dock.
* Define logging semantics.

Current Engine focus (Tv_1.2):

* `create` operation
* `initiation` state
* Shared in-memory state (DB-backed state later)

Engine trusts validated flow input but does not trust persistence.

---

### Validators

Validation is **layered**, not centralized.

#### 1. Protocol / Endpoint Validation

* Lives at Dock.
* Ensures request and response shape correctness.
* Fast, strict, synchronous.

#### 2. Flow Validator

* Context-aware.
* Stage-aware.
* Allows partial or evolving data.
* May normalize or annotate input.
* Focused on *permission*, not perfection.

#### 3. Boundary Validator

* Stateless and ruthless.
* Ensures data is acceptable for persistence.
* Enforces DB-level invariants (types, formats, constraints).
* No awareness of flow or intent.

---

### Touch

**Role:** Persistence interface.

Responsibilities:

* Execute CRUD operations.
* Log loudly.
* Remain boring.

Touch does not:

* Validate business logic.
* Decide behavior.
* Mutate flow.

It assumes all data passed to it is persistence-safe.

---

## Database

### Purpose

The DB stores **deferred operations**, not business entities.

### Current Schema (Example)

```sql
DROP TYPE IF EXISTS enum_status;
CREATE TYPE enum_status AS ENUM ('pending', 'sent', 'failed');

CREATE TABLE IF NOT EXISTS users (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    userID UUID NOT NULL DEFAULT uuidv7(),
    payload JSONB NOT NULL,
    execute_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    deferred_status enum_status NOT NULL DEFAULT 'pending',
    contact_id JSONB NOT NULL
);
```

Schema evolution is tracked explicitly.

---

## File Structure

```
TEST_v1_2/
|
|- dock/
|   |
|   |- endpoints.py        # protocol boundary (HTTP)
|   |- resolver.py            # intent → handler resolution
|   |- markdown/           # notes / flow docs (optional)
|
|- engine/
|   |
|   |- control/            # engine-level helpers (may shrink later)
|   |- operation_manager/  # operation states + transitions
|   |- dock_facer/         # controlled interface from Dock → Engine
|   |- touch_facer/        # controlled interface from Engine → Touch
|
|- touch/
|   |
|   |- middleman/          # engine-facing persistence layer (logs loudly)
|   |- ORM/                # CRUD implementations
|   |- DB/
|       |- base_schema.sql # canonical DB schema
|       |- migrations/     # schema evolution
|
|- utility/
|   |
|   |- logger.py           # centralized logging logic
|   |
|   |- validators/
|   |   |- protocol.py     # endpoint / IO validation
|   |   |- flow.py         # stage-aware validation
|   |   |- boundary.py     # DB-aligned strict validation
|   |
|   |- pydantic_models/
|       |- protocol_schema.py  # request / response shapes
|       |- flow_schema.py      # operation / state schemas
|       |- boundary_schema.py  # persistence-ready schemas
|
|- structure.md
|- nextGen.md
```

---

## Version Intent

**Tv_1.2 is a stabilization release.**

* One flag works end-to-end.
* Flow is canonical.
* Validation is named and layered.
* DB integration is minimal but real.

Future versions will:

* Expand CRUD support.
* Harden endpoint contracts.
* Persist operation state.
* Add orchestration layers.

This version exists to make everything after it sane.